# 构建

<script>
     var menu = {
        "m4_1_1":'/"[^"]*"/ 替代 /".*?"/',
        "m4_2_1":"略",
        "m4_3_1":"/a+/，可以修改成/aa*/",
        "m4_4_1":"比如/this|that/，修改成/th(?:is|at)/",
        "m4_5_1":"/red|read/，可以修改成/rea?d/， 但是可读性不强。",
        "m5_1_1":'符号部分：[+-] <br>整数部分：\d+ <br>小数部分：\.\d+ <br><br>要匹配1.23、+1.23、-1.23，可以用:/^[+-]?\d+\.\d+$/<br>要匹配10、+10、-10，可以用/^[+-]?\d+$/<br>要匹配.2、+.2、-.2，可以用/^[+-]?\.\d+$/<br><br>/^[+-]?(\d+\.\d+|\d+|\.\d+)$/'
    }
</script>

## 1、平衡法则

------------

* 匹配预期的字符串
* 不匹配非预期的字符串
* 可读性和可维护性
* 效率

## 2、构建正则前提

-------------

1. 能否用正则？ 比如： 1010010001....
2. 是否有必要用正则？ **多用原生api，split、substr、indexof、search等**
3. 对于复杂正则，最好简化成多个小正则。

## 3、准确性（构建的步骤）

----------------

1. 把大问题分割成小问题
2. 把小问题组合提取公共部分，优化简略代码
3. 如果一次性完成一个大的构建，容易出问题！

## 4、效率

------------------------

1. {{"使用具体型字符组来代替通配符，来消除回溯" | exp_pop(0,"menu.m4_1_1",0)}}
2. {{"不使用分组引用和反引用时，使用非捕获型分组" | exp_pop(0,"menu.m4_2_1",0)}}
3. {{"独立出确定字符" | exp_pop(0,"menu.m4_3_1",0)}}
4. {{"提取分支公共部分" | exp_pop(0,"menu.m4_4_1",0)}}
5. {{"减少分支的数量，缩小它们的范围" | exp_pop(0,"menu.m4_5_1",0)}}

## 5、浮点数的正则

-------------

> 1.23、+1.23、-1.23<br>
> 10、+10、-10<br>
> .2、+.2、-.2<br>
>
> {{"答案"| exp_pop(0,"menu.m5_1_1",0)}}






# 位置匹配

<script>
    var menu = {
        "m2_a_1":'/^|$/g',
        "m2_a_2":'/^|$/gm',
        "m2_b_1":'\\b是单词边界，包括： <br>1.\\w和\\W之间的位置 <br>2.\\w和^之间的位置 <br>3.\\w和$之间的位置。',
        "m2_b_2":'[#JS#] #Lesson_01#.#mp4#',
        "m2_b_3":'#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4',
        "m2_c_1":'/(?=l)/g',
        "m2_c_2":'/(?!l)/g',
        "m4_a_1":'/.^/',
        "m4_b_1":'/(?=\d{3}$)/g',
        "m4_b_2":'/(?=(\d{3})+$)/g',
        "m4_b_3":'/(?!^)(?=(\d{3})+$)/g',
        "m4_b_4":'/(?!\\b)(?=(\\d{3})+\\b)/g <br> /\\B(?=(\\d{3})+\\b)/g',
        "m4_c_1":'/^[0-9A-Za-z]{6,12}$/',
        "m4_c_2":'/(?=.*[0-9])^[0-9A-Za-z]{6,12}$/ <br> 这里还有点不理解：翻译成大白话，就是接下来的字符，必须包含个数字',
        "m4_c_3":'/(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]{6,12}$/',
        "m4_c_4":'/(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/;'
    }
</script>




1. 什么是位置？

   > 相邻字符之间的位置

2. 如何匹配位置

   > 在ES5中，共有6个**锚字符**：
   >
   > ^ $ \b \B (?=p) (?!p)
   >
   > >  es9支持后行断言, v8 4.9(chrome 62)支持后行断言.

   1. 脱字符和美元符号

      > ^（脱字符）匹配开头，在多行匹配中匹配行开头。
      >
      > $（美元符号）匹配结尾，在多行匹配中匹配行结尾。

      > 练习1: "hello" -> "#hello#"
      >
      > {{"answer" | exp_pop(0,"menu.m2_a_1",0)}}
      >
      > 
      >
      > 练习2: "I\nlove\njavascript"  ->  每一行行首和行尾都加#号
      >
      > {{"answer" | exp_pop(0,"menu.m2_a_2",0)}}

   2. **\b和\B**

      > \b 代表什么?
      >
      > {{"answer" | exp_pop(0,"menu.m2_b_1",0)}}
      >
      > 
      >
      > ```js
      > var result = "[JS] Lesson_01.mp4".replace(/\b/g, '#');
      > 
      > console.log(result);
      > ```
      >
      > {{"answer" | exp_pop(0,"menu.m2_b_2",0)}}
      >
      > 
      >
      > ```js
      > var result = "[JS] Lesson_01.mp4".replace(/\B/g, '#');
      > 
      > console.log(result); 
      > ```
      >
      > {{"answer" | exp_pop(0,"menu.m2_b_3",0)}}

   3. **(?=p)和(?!p)**

      > 匹配 : p前面的那个位置(**更详细的解释在下面**)
      >
      > 练习1: "hello" -> "he#l#lo"
      >
      > {{"answer" | exp_pop(0,"menu.m2_c_1",0)}}
      >
      > 
      >
      > 练习2: "hello" -> "#h#ell#o#"
      >
      > {{"answer" | exp_pop(0,"menu.m2_c_2",0)}}

3. 位置的特性

   > 位置理解成空字符

4. 案例

   1. 不匹配任何

      {{"answer" | exp_pop(0,"menu.m4_a_1",0)}}

   2. 数字的千位分隔符表示

      > * 弄出最后一个逗号
      >
      >   {{"answer" | exp_pop(0,"menu.m4_b_1",0)}}
      >
      > * 弄出所有逗号
      >
      >   {{"answer" | exp_pop(0,"menu.m4_b_2",0)}}
      >
      > * 不匹配开头
      >
      >   {{"answer" | exp_pop(0,"menu.m4_b_3",0)}}
      >
      > * 支持其他形式: "12345678 123456789"
      >
      >   {{"answer" | exp_pop(0,"menu.m4_b_4",0)}}

   3. 验证密码问题

      密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符。

      > 1. 不考虑2种字符
      >
      >    {{"answer" | exp_pop(0,"menu.m4_c_1",0)}}
      >
      > 2. 判断是否包含有某一种字符
      >
      >    {{"answer" | exp_pop(0,"menu.m4_c_2",0)}}
      >
      > 3. 同时包含具体两种字符
      >
      >    {{"answer" | exp_pop(0,"menu.m4_c_3",0)}}
      >
      > 4. 用另一种方法解答: (?!p)
      >
      >    {{"answer" | exp_pop(0,"menu.m4_c_4",0)}}

# 疑问

### 问题

> console.log(obj.replace(/(?=(\d{3})+$)/g, ',')) 

### 解释

> **(?=pattern) 正向先行断言** ： 代表字符串中的一个位置，**紧接该位置之后**的字符序列**能够匹配**pattern。 
>
> **(?!pattern) 负向先行断言** ： 代表字符串中的一个位置，**紧接该位置之后**的字符序列**不能匹配**pattern。 
>
> **(?<=pattern) 正向后行断言** ：代表字符串中的一个位置，**紧接该位置之前**的字符序列**能够匹配**pattern。
>
> **(?<!pattern) 负向后行断言** ： 代表字符串中的一个位置，**紧接该位置之前**的字符序列**不能匹配**pattern。 
>
> 参考：[先行和后行断言](https://blog.51cto.com/cnn237111/749047)

### 我的理解是

> * 对于先行断言（正向先行断言、负向先行断言），只使用美元符。
> * 对于后行断言（正向后行断言、负向后行断言），只使用脱字符。
>
> 为什么是“**只使用**”，不然会失去先行和后行断言的意义！

### 练习

> ps: 字符串中不包含某个字符，用\[^...]形式就可以了; 不包含某个字符串呢？只能使用负向断言了！
>
> 例如判断一句话中包含this，但不包含that。 
>
> 我的答案：
>
> var str = "that is this"
>
> var r_has_this = /(?=(\bthis\b))/;
>
> var r_not_that = /(?!(that))/  //思考为什么是true？应该怎么写？
>
> 。。。
>
> 未完待续。。。

> 作者答案：
>
> 。。。。
>
> 未完待续。。。